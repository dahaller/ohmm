#!/usr/bin/env bash

# TODO
# separate arguments by || and && possibly
# colors
# history
# auto-complete
# looping
# appending
# search
# edit info

pidof mplayer | xargs kill &>/dev/null

# create fifo
FIFO=/var/tmp/.fifo
if [ ! -e $FIFO ]; then
	mkfifo $FIFO
fi

MY_STDOUT=/var/tmp/.ohmm_out
QUEUE=/var/tmp/.plyst
SLEEP=.1s
# TODO make generic
EXE_PATH=/home/nicolas/code/ohmm

# create backend
VOLUME=50
PWD=$(pwd)
V_INC=10
LOOP=-1
MARGS="-slave -loop $LOOP -idle -quiet -input file=$FIFO"
mplayer $MARGS > $MY_STDOUT 2>&1 &

# yet another wrapper for sending mplayer what to play
function ohmm_play {
	if [ -z "$1" ]; then
		for f in `find . \( ! -iname ".*" \) -type f`; do
			if [ -d $f ]; then
				ODIR=$PWD
				cd $f
				cd $ODIR	
			else
#				spaces suck, I am going to fix them for you
				cp -n $f $(echo $f | tr ' ' '_') &>/dev/null && rm $f
				echo "$PWD/$(echo $f | tr ' ' '_')" >> $QUEUE 
			fi
		done
	else
		if [ -e "$1" ]; then
			echo "$PWD/$1" >> $QUEUE
		else
			echo "$1 does not exist"
		fi
	fi
}

# execute the shell command with the line tokenized into array
function shell_cmd {
	LINE_CMD=""
	for s in ${CMD[@]}; do
		LINE_CMD="$LINE_CMD $s"
	done
	$LINE_CMD
}

# driver loop
while true; do
CMD=""
# 	prompt
	echo -n "ohmm|$PWD "

# 	get user command and tokenize into array
	read -a CMD 
	
	if [ -z ${CMD[0]} ]; then
		continue
	fi

#	check if I recognize it
	if [ "${CMD[0]}" = "play" ]; then
		if [ -e $QUEUE ]; then
			rm $QUEUE
		fi

		OIFS=$IFS
		IFS=$'\n'
		ohmm_play ${CMD[1]}
		IFS="$OIFS"
		echo "loadlist $QUEUE -loop $LOOP 0" > $FIFO
	elif [ "${CMD[0]}" = "repeat" ]; then
		if [ "${CMD[1]}" = "none" ]; then
			LOOP=-1
		elif [ "${CMD[1]}" = "all" ]; then
			LOOP=0
		elif [ "${CMD[1]}" = "num" ]; then
			LOOP=${CMD[2]}
		fi

		echo "set loop $LOOP" > $FIFO
	

	elif [ "${CMD[0]}" = "shuffle" ]; then
		echo "loadlist $QUEUE -loop $LOOP -shuffle" > $FIFO

#	TODO pretty shitty help -- should make it better eventually
	elif [ "${CMD[0]}" = "help" ] || [ "${CMD[0]}" = "h" ]; then
		cat $EXE_PATH/README

#	append song to currently on the fly playlist
	elif [ "${CMD[0]}" = "add" ]; then
#		append to playlist file
		if [ -e $QUEUE ]; then
			echo "$PWD/${CMD[1]}" >> $QUEUE
#			append playlist
			echo "loadfile $PWD/${CMD[1]} 1" > $FIFO
		else
#			need to create the playlist
			echo "$PWD/${CMD[1]}" > $QUEUE
			echo "loadlist $QUEUE -loop $LOOP 1" > $FIFO
		fi

	elif [ "${CMD[0]}" = "pause" ]; then
		echo "pause" > $FIFO

	elif [ "${CMD[0]}" = "next" ] || [ "${CMD[0]}" = "n" ]; then
		echo "pt_step 1" > $FIFO

	elif [ "${CMD[0]}" = "back" ] || [ "${CMD[0]}" = "b" ]; then
		echo "pt_step -1" > $FIFO

	elif [ "${CMD[0]}" = "up" ] || [ "${CMD[0]}" = "u" ]; then
#		bound the upper limit of the volume value
		if [ $VOLUME -lt 100 ]; then
			VOLUME=$(($VOLUME+$V_INC))
		fi
		echo "set volume $VOLUME 0" > $FIFO
		echo "VOLUME = $VOLUME%"

	elif [ "${CMD[0]}" = "down" ] || [ "${CMD[0]}" = "d" ]; then
#		bound the lower limit of the volume value
		if [ $VOLUME -gt 0 ]; then
			VOLUME=$(($VOLUME-$V_INC))
		fi
		echo "set volume $VOLUME 0" > $FIFO
		echo "VOLUME = $VOLUME%"

#	TODO be able to edit info and search
	elif [ "${CMD[0]}" = "info" ] || [ "${CMD[0]}" = "i" ]; then
		echo "get_file_name" > $FIFO
		echo "get_meta_track" > $FIFO
		echo "get_meta_artist" > $FIFO
		echo "get_meta_album" > $FIFO
		echo "get_percent_pos" > $FIFO
		sleep $SLEEP 
		tail $MY_STDOUT -n 5 | grep "ANS_" | 
			sed -r 's/ANS_PERCENT_POSITION=([0-9][0-9]*)/\1% done/g' |
			sed -r 's/.*=//g' | 
			sed -r 's/PROPERTY_UNAVAILABLE/nothing is playing/g'
	
	elif [ "${CMD[0]}" = "stop" ]; then
		echo "stop" > $FIFO
	
	elif [ "${CMD[0]}" = "quit" ] || [ "${CMD[0]}" = "q" ]; then
		echo "quit" > $FIFO
		if [-e $QUEUE ]; then
			rm $QUEUE
		fi

		rm $FIFO
		rm $MY_STDOUT
		clear
		echo -n $PS1
		break

	else
		shell_cmd $CMD
	fi
done
