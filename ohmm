#!/usr/bin/env bash

# TODO
# separate arguments by || and && possibly
# colors
# history
# auto-complete
# looping
# appending
# search
# edit info

# a little excessive? TODO
pidof mplayer | xargs kill &>/dev/null

# create fifo
FIFO=/var/tmp/.fifo
if [ ! -e $FIFO ]; then
	mkfifo $FIFO
fi

EXE_PATH=$(dirname "$0")
EXE_PATH=$(cd $EXE_PATH && pwd)

MY_STDOUT=/var/tmp/.ohmm_out
QUEUE=/var/tmp/.plyst
SLEEP=.1s
IS_SHUFFLE=false
# create backend
VOLUME=50
PWD=$(pwd)
V_INC=10
LOOP=-1
MARGS="-slave -loop $LOOP -idle -quiet -input file=$FIFO"
mplayer $MARGS > $MY_STDOUT 2>&1 &

# yet another wrapper for sending mplayer what to play
function ohmm_play {
	if [ -z "$1" ]; then
#		should filter just music extensions I think are applicable
		for f in `find . \( ! -iname ".*" \) -type f`; do
#			I have not decided what I want to do here
			if [ -d $f ]; then
				ODIR=$PWD
				cd $f
				cd $ODIR	
			else
#				spaces suck, I am going to fix them for you
				cp -n $f $(echo $f | tr ' ' '_') &>/dev/null && rm $f
				echo "$PWD/$(echo $f | tr ' ' '_')" >> $QUEUE 
			fi
		done
	else
		if [ -e "$1" ]; then
			if [ -d "$1" ]; then
				ODIR=$PWD
				cd "$1"
				ohmm_play "" ""
				cd $ODIR
			else
				echo "$PWD/$1" >> $QUEUE
			fi
		else
			echo "$1 does not exist"
		fi
	fi
}

# execute the shell command with the line tokenized into array
function shell_cmd {
	LINE_CMD=""
	for s in ${CMD[@]}; do
		LINE_CMD="$LINE_CMD $s"
	done
	$LINE_CMD
}

# driver loop
while true; do
CMD=""
# 	prompt
	echo -n "ohmm|$(basename $PWD) "

# 	get user command and tokenize into array
	read -a CMD 
	
	if [ -z ${CMD[0]} ]; then
		continue
	fi

#	check if I recognize it
	if [ "${CMD[0]}" = "play" ]; then
#		clear old previous from play
		if [ -e $QUEUE ]; then
			rm $QUEUE
		fi

		OIFS=$IFS
		IFS=$'\n'
		ohmm_play ${CMD[1]}


		IFS="$OIFS"
		echo "loadlist $QUEUE -loop $LOOP 0" > $FIFO
#	TODO
	elif [ "${CMD[0]}" = "repeat" ]; then
		if [ "${CMD[1]}" = "none" ]; then
			LOOP=-1
		elif [ "${CMD[1]}" = "all" ]; then
			LOOP=0
		elif [ "${CMD[1]}" = "num" ]; then
			LOOP=${CMD[2]}
		fi

		echo "set loop $LOOP" > $FIFO
	

	elif [ "${CMD[0]}" = "shuffle" ]; then
		if [ "${CMD[1]}" = "on" ]; then
			IS_SHUFFLE=true
		elif [ "${CMD[1]}" = "off" ]; then
			IS_SHUFFLE=false
		else
			echo "bad argument: ${CMD[1]}"
		fi

	elif [ "${CMD[0]}" = "s" ]; then
		if [ $IS_SHUFFLE ]; then
			IS_SHUFFLE=false
		else
			IS_SHUFFLE=true
		fi

#	TODO pretty shitty help -- should make it better eventually
	elif [ "${CMD[0]}" = "help" ] || [ "${CMD[0]}" = "h" ]; then
		cat $EXE_PATH/README

#	append song to currently on the fly playlist
	elif [ "${CMD[0]}" = "add" ]; then
		if [ -e "${CMD[1]}" ]; then
			if [ -d "${CMD[1]}" ]; then
				ODIR=$PWD
				cd "${CMD[1]}"
				for f in `find . \( ! -iname ".*" \) -type f`; do
					if [ -e $QUEUE ] && [ -f $f ]; then	
						echo "$PWD/${CMD[1]}/$f" >> $QUEUE
						echo "loadfile $PWD/${CMD[1]}/$f 1" > $FIFO
					else
						echo "$PWD/${CMD[1]}/$f" > $QUEUE
						echo "loadlist $QUEUE -loop $LOOP 1" > $FIFO
					fi
				done
				cd $ODIR
			else
#				append to playlist file
				if [ -e $QUEUE ]; then
					echo "$PWD/${CMD[1]}" >> $QUEUE
#					append playlist
					echo "loadfile $PWD/${CMD[1]} 1" > $FIFO
				else
#					need to create the playlist
					echo "$PWD/${CMD[1]}" > $QUEUE
					echo "loadlist $QUEUE -loop $LOOP 1" > $FIFO
				fi
			fi
		else
			echo "${CMD[0]} does not exist"
		fi

	elif [ "${CMD[0]}" = "pause" ]; then
		echo "pause" > $FIFO

	elif [ "${CMD[0]}" = "next" ] || [ "${CMD[0]}" = "n" ]; then
		echo "pt_step 1" > $FIFO

	elif [ "${CMD[0]}" = "back" ] || [ "${CMD[0]}" = "b" ]; then
		echo "pt_step -1" > $FIFO

	elif [ "${CMD[0]}" = "up" ] || [ "${CMD[0]}" = "u" ]; then
#		bound the upper limit of the volume value
		if [ $VOLUME -lt 100 ]; then
			VOLUME=$(($VOLUME+$V_INC))
		fi
		echo "set volume $VOLUME 0" > $FIFO
		echo "VOLUME = $VOLUME%"

	elif [ "${CMD[0]}" = "down" ] || [ "${CMD[0]}" = "d" ]; then
#		bound the lower limit of the volume value
		if [ $VOLUME -gt 0 ]; then
			VOLUME=$(($VOLUME-$V_INC))
		fi
		echo "set volume $VOLUME 0" > $FIFO
		echo "VOLUME = $VOLUME%"

#	TODO be able to edit info and search
	elif [ "${CMD[0]}" = "info" ] || [ "${CMD[0]}" = "i" ]; then
		echo "get_file_name" > $FIFO
		echo "get_meta_track" > $FIFO
		echo "get_meta_artist" > $FIFO
		echo "get_meta_album" > $FIFO
		echo "get_percent_pos" > $FIFO
		sleep $SLEEP 
		tail $MY_STDOUT -n 5 | grep "ANS_" | 
			sed -r 's/ANS_PERCENT_POSITION=([0-9][0-9]*)/\1% done/g' |
			sed -r 's/.*=//g' | 
			sed -r 's/PROPERTY_UNAVAILABLE/nothing is playing/g'
	
	elif [ "${CMD[0]}" = "stop" ]; then
		echo "stop" > $FIFO
	
	elif [ "${CMD[0]}" = "quit" ] || [ "${CMD[0]}" = "q" ]; then
		echo "quit" > $FIFO
		if [ -e $QUEUE ]; then
			rm $QUEUE
			echo here
		fi

		rm $FIFO
		rm $MY_STDOUT
		echo -n $PS1
		break

	else
		shell_cmd $CMD
	fi
done
