#!/usr/bin/env bash

# TODO
# colors
# history
# auto-complete
# looping
# search

# a little excessive? TODO
pidof mplayer | xargs kill &>/dev/null
PWD=$(pwd)
EXE_PATH=$(dirname "$0")
EXE_PATH=$(cd $EXE_PATH && pwd)
FUNCS="$EXE_PATH/func_ohmm"
VARS="$EXE_PATH/var_ohmm"

bind -x '"\t":"tab"' &> /dev/null

if [ ! -e $FUNCS ] || [ ! -e $VARS ]; then
	echo "Where are my guts? Check that $FUNCS and $VARS exist"
	exit
fi

source $FUNCS

if [ ! -e $LIBRARY ]; then
	mkdir $LIBRARY
fi

if [ ! -e $FIFO ]; then
	mkfifo $FIFO
fi

MARGS="-slave -loop $LOOP -idle -quiet -input file=$FIFO"
mplayer $MARGS > $MY_STDOUT 2>&1 &

# command handler
function ohmm_driver {
#	nothing
	if [ -z ${CMD[0]} ]; then
		continue

#	add music from the fly onto the mplayer's play-list
	elif [ "${CMD[0]}" = "add" ]; then
		ohmm_add

#	move up playlist file
	elif [ "${CMD[0]}" = "back" ] || [ "${CMD[0]}" = "b" ]; then
		ohmm_back

#	decrease volume
	elif [ "${CMD[0]}" = "down" ] || [ "${CMD[0]}" = "d" ]; then
		ohmm_volume -1

	elif [ "${CMD[0]}" = "edit" ]; then
		ohmm_edit

#	print help
	elif [ "${CMD[0]}" = "help" ] || [ "${CMD[0]}" = "h" ]; then
		cat $EXE_PATH/README

#	iterate over playlist to the first chance to play song
	elif [ "${CMD[0]}" = "goto" ] || [ "${CMD[0]}" = "go" ]; then
		ohmm_goto

#	get info of the current song playing
	elif [ "${CMD[0]}" = "info" ] || [ "${CMD[0]}" = "i" ]; then
		ohmm_get_info

#	list the contents of the current mplayer play-list
	elif [ "${CMD[0]}" = "list" ] || [ "${CMD[0]}" = "l" ]; then
		ohmm_list

#	prefix for different mtp commands
	elif [ "${CMD[0]}" = "mtp" ]; then
		ohmm_mtp

#	move down playlist file
	elif [ "${CMD[0]}" = "next" ] || [ "${CMD[0]}" = "n" ]; then
		ohmm_next
		
#	pause
	elif [ "${CMD[0]}" = "pause" ] || [ "${CMD[0]}" = "p" ]; then
		echo "pause" > $FIFO

#	create $QUEUE, play song or songs in dir tree
	elif [ "${CMD[0]}" = "play" ]; then
		ohmm_play

#	get position in the playlist
	elif [ "${CMD[0]}" = "position" ] || [ "${CMD[0]}" = "pos" ]; then
		ohmm_get_position

#	clean up and leave
	elif [ "${CMD[0]}" = "quit" ] || [ "${CMD[0]}" = "q" ]; then
		ohmm_quit
		break
#	give options to repeat the current list
	elif [ "${CMD[0]}" = "repeat" ]; then
		ohmm_repeat

#	shorthand, toggle the current value
	elif [ "${CMD[0]}" = "s" ]; then
		ohmm_shuffle_toggle

#	verbose way to turn shuffle on|off
	elif [ "${CMD[0]}" = "shuffle" ]; then
		ohmm_shuffle

#	delete play-list
	elif [ "${CMD[0]}" = "stop" ]; then
		echo "stop" > $FIFO
		rm $QUEUE

#	increase volume
	elif [ "${CMD[0]}" = "up" ] || [ "${CMD[0]}" = "u" ]; then
		ohmm_volume 1

#	I don't recognize the command, leave to shell
	else
		ohmm_shell_cmd $CMD
	fi

}

tab(){
#	just get rid of empty lines
	if [ -z "$READLINE_LINE" ]; then
		return
	fi
	STRING=""
#	tokenize
	read -a STRING <<< "$READLINE_LINE"
#	only care about the last token
	QUERY=${STRING[${#STRING[@]} - 1]}
#	TODO improve search
	ls | grep "$QUERY" > $COMPLETE_LIST
#	see how many results I got
	TEMP=$(wc -l $COMPLETE_LIST)
	TEMP=$(echo $TEMP | sed -r 's/([0-9]*).*/\1/g')
#	oh, auto-complete
	if [ $TEMP = "1" ]; then
		STRING[${#STRING[@]} - 1]=$(cat $COMPLETE_LIST | sed -n 1p)
		READLINE_LINE=${STRING[@]}
	else
		cat $COMPLETE_LIST
	fi
	rm $COMPLETE_LIST
}

function get_command {
# clear previous input
	CMD=""
	RAW=""
# 	get user command and tokenize, assume TAB is happening
	read -p "ohmm|$(basename $PWD) " -e RAW
#	ok now tokenize
	read -a CMD <<< "$RAW"
#	handle CMD
	ohmm_driver
}

# driver loop
while true; do
	get_command
done

