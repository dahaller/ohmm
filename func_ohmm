#!/usr/bin/env bash

VARS="$EXE_PATH/var_ohmm"
source $VARS
# ===============================================================

function ohmm_add {
	if [ -e "${CMD[1]}" ]; then
		if [ -d "${CMD[1]}" ]; then
			ODIR=$PWD
			cd "${CMD[1]}"
			for f in `find . \( ! -iname ".*" \) -type f` -iregex $FORMATS; do
				if [ -e $QUEUE ] && [ -f $f ]; then	
					echo "$PWD/${CMD[1]}/$f" >> $QUEUE
					echo "loadfile $PWD/${CMD[1]}/$f 1" > $FIFO
				else
					echo "$PWD/${CMD[1]}/$f" > $QUEUE
					echo "loadlist $QUEUE 1" > $FIFO
				fi
			done
			cd $ODIR
		else
#			append to playlist file
			if [ -e $QUEUE ]; then
				echo "$PWD/${CMD[1]}" >> $QUEUE
#				append playlist
				echo "loadfile $PWD/${CMD[1]} 1" > $FIFO
			else
#				need to create the playlist
				echo "$PWD/${CMD[1]}" > $QUEUE
				echo "loadlist QUEUE 1" > $FIFO
			fi
		fi
	else
		if [ -z "${CMD[1]}" ]; then
			echo "No argument was provided"
		else
			echo "${CMD[1]} does not exist"
		fi
	fi
}

function ohmm_back {
	ITER=${CMD[1]}
	if [ -z $ITER ]; then
		echo "pt_step -1" > $FIFO
	elif [ $ITER -gt 1 ]; then
		echo "pt_step $ITER" > $FIFO
	else
		echo "Bad argument $ITER"
	fi
}

# TODO - test
function ohmm_backup {
	UPDATE=.ohmm_backup_in_process.tar.gz
	tar -czvf $UPDATE "$LIBRARY"
	rsync $UPDATE "EXE_PATH/library.tar.gz"
	rm $UPDATE
	UPDATE=""
}

# TODO - test, deal with overwriting better
function ohmm_extract {
	DIR="${CMD[2]}"
	ODIR=$(pwd)

#	check for empty argument - I will use current directory if needed
	if [ ! -z "$DIR" ]; then
		cd $DIR
	fi
	for f in `find . \( ! -iname ".*" \) -type f -iregex $FORMATS`; do
		if [ "${CMD[1]}" = "soft" ]; then
			ln -s $f "$LIBRARY/$(basename $f)"
		elif [ "${CMD[1]}" = "hard" ]; then
			mv -n $f "$LIBRARY/$(basename $f)"
		else
			echo "Bad argument ${CMD[1]}"
			break
		fi
	done
	cd $ODIR	
}

# TODO get number in playlist
function ohmm_get_info {
	echo "get_file_name" > $FIFO
	echo "get_meta_title" > $FIFO
	echo "get_meta_track" > $FIFO
	echo "get_meta_artist" > $FIFO
	echo "get_meta_album" > $FIFO
	echo "get_percent_pos" > $FIFO
	echo "get_time_pos" > $FIFO
	sleep $SLEEP 
	tail $MY_STDOUT -n 7 | grep "ANS_" | 
		sed -r 's/ANS_PERCENT_POSITION=([0-9][0-9]*)/\1% done/g' |
		sed -r 's/ANS_TIME_POSITION=([0-9][0-9]*.[0-9][0-9]*)/\1 seconds elapsed/g' |
		sed -r 's/.*FILENAME=(.*)/File: \1/g' | 
		sed -r 's/.*TITLE=(.*)/Name: \1/g' |
		sed -r 's/.*TRACK=(.*)/Track: \1/g' |
		sed -r 's/.*ARTIST=(.*)/Artist: \1/g' |
		sed -r 's/.*ALBUM=(.*)/Album: \1/g' |
		sed -r 's/PROPERTY_UNAVAILABLE/nothing is playing/g'
}

# TODO - in playlist get position
function ohmm_get_position {
	echo "not implemented"
}

# TODO goto string argument - first instance
function ohmm_goto {
	echo "not implemented"
}

# TODO - clean up paths
function ohmm_list {
	if [ -e $QUEUE ]; then
		cat $QUEUE | less -N
	else
		echo "Nothing to show"
	fi
}

# TODO deal with mtp library
function ohmm_mtp {
	echo "not implemented"
}

function ohmm_next {
	ITER=${CMD[1]}
	if [ -z "$ITER" ]; then
		echo "pt_step 1" > $FIFO
	elif [ $ITER -gt 1 ]; then
		echo "pt_step $ITER" > $FIFO
	else
		echo "Bad argument $ITER"
	fi
}

function ohmm_play {
	OIFS=$IFS
	IFS=$'\n'
#	get rid of old stuff
	if [ -e $QUEUE ]; then
		rm $QUEUE
	fi
	if [ -z "${CMD[1]}" ]; then
#		should filter just music extensions I think are applicable
		for f in `find . \( ! -iname ".*" \) -type f -iregex $FORMATS`; do
#			I have not decided what I want to do here
			if [ -d $f ]; then
				continue
			else
#				spaces suck, I am going to fix them for you
				cp -n $f $(echo $f | tr ' ' '_') &>/dev/null && rm $f
				echo "$PWD/$(echo $f | tr ' ' '_')" >> $QUEUE 
			fi
		done
	else
		if [ -e "${CMD[0]}" ]; then
			if [ -d "${CMD[1]}" ]; then
				ODIR=$PWD
				cd "$1"
				ohmm_play "" ""
				cd $ODIR
			else
				echo "$PWD/${CMD[1]}" >> $QUEUE
			fi
		else
			echo "${CMD[1]} does not exist"
		fi
	fi
	echo "loadlist $QUEUE 0" > $FIFO
	IFS="$OIFS"
}

function ohmm_quit {
	echo "quit" > $FIFO
	if [ -e $QUEUE ]; then
		rm $QUEUE
	fi
	rm $FIFO
	rm $MY_STDOUT
	echo -n $PS1
}

# TODO fix
function ohmm_repeat {
	if [ "${CMD[1]}" = "none" ]; then
		LOOP=-1
	elif [ "${CMD[1]}" = "all" ]; then
		LOOP=0
	elif [ "${CMD[1]}" = "num" ]; then
		LOOP=${CMD[2]}
	fi

	echo "set loop $LOOP" > $FIFO
}

function ohmm_shell_cmd {
	LINE_CMD=""
	for s in ${CMD[@]}; do
		LINE_CMD="$LINE_CMD $s"
	done
	$LINE_CMD
}

# TODO fix
function ohmm_shuffle {
	if [ "${CMD[1]}" = "on" ]; then
		IS_SHUFFLE=true
	elif [ "${CMD[1]}" = "off" ]; then
		IS_SHUFFLE=false
	else
		echo "bad argument: ${CMD[1]}"
	fi
}

function ohmm_shuffle_toggle {
	if [ $IS_SHUFFLE ]; then
		IS_SHUFFLE=false
	else
		IS_SHUFFLE=true
	fi
}

function ohmm_volume {
	if [ $1 -gt 0 ]; then
#		bound the upper limit of the volume value
		if [ $VOLUME -lt 100 ]; then
			VOLUME=$(($VOLUME+$V_INC))
		fi
		echo "set volume $VOLUME 0" > $FIFO
		echo "VOLUME = $VOLUME%"

	else
#		bound the lower limit of the volume value
		if [ $VOLUME -gt 0 ]; then
			VOLUME=$(($VOLUME-$V_INC))
		fi
		echo "set volume $VOLUME 0" > $FIFO
		echo "VOLUME = $VOLUME%"

	fi
}

